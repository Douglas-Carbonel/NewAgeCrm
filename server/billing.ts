import { storage } from "./storage";
import { timeTrackingService } from "./timeTracking";
import type { Invoice, InsertInvoice, Project, Client } from "@shared/schema";

interface BillingRule {
  id: number;
  projectId?: number;
  clientId?: number;
  frequency: 'weekly' | 'monthly' | 'on_completion';
  dayOfWeek?: number; // 0-6 for weekly
  dayOfMonth?: number; // 1-31 for monthly
  isActive: boolean;
  autoSend: boolean;
  taxRate: number; // percentage
  description: string;
}

interface BillingStats {
  totalUnbilledHours: number;
  totalUnbilledAmount: number;
  totalBilledThisMonth: number;
  averageHourlyRate: number;
  nextBillingDates: Array<{
    projectName: string;
    clientName: string;
    nextDate: string;
    estimatedAmount: number;
  }>;
}

interface UnbilledTimeEntry {
  id: number;
  projectId: number;
  projectName: string;
  clientName: string;
  description: string;
  duration: number;
  hourlyRate: number;
  totalCost: number;
  date: string;
}

class BillingService {
  private billingRules: Map<number, BillingRule> = new Map();
  private currentRuleId = 1;

  constructor() {
    this.initializeDefaultRules();
  }

  private initializeDefaultRules() {
    // Default monthly billing rule
    const defaultRule: BillingRule = {
      id: this.currentRuleId++,
      frequency: 'monthly',
      dayOfMonth: 1,
      isActive: true,
      autoSend: false,
      taxRate: 10.0,
      description: 'Monthly billing on the 1st'
    };
    this.billingRules.set(defaultRule.id, defaultRule);
  }

  async generateInvoiceFromTimeEntries(projectId: number, timeEntryIds: number[]): Promise<Invoice> {
    try {
      const project = await storage.getProject(projectId);
      if (!project) {
        throw new Error('Project not found');
      }

      const timeEntries = await timeTrackingService.getTimeEntries(projectId);
      const selectedEntries = timeEntries.filter(entry => timeEntryIds.includes(entry.id));
      
      if (selectedEntries.length === 0) {
        throw new Error('No valid time entries found');
      }

      const totalAmount = selectedEntries.reduce((sum, entry) => sum + entry.totalCost, 0);
      const taxRate = this.getTaxRateForProject(projectId);
      const taxAmount = totalAmount * (taxRate / 100);
      const finalAmount = totalAmount + taxAmount;

      const invoiceNumber = `INV-${Date.now()}-${projectId}`;
      const dueDate = new Date();
      dueDate.setDate(dueDate.getDate() + 30); // 30 days from now

      const invoiceData: InsertInvoice = {
        invoiceNumber,
        clientId: project.clientId,
        projectId: projectId,
        amount: finalAmount.toFixed(2),
        status: 'draft',
        dueDate: dueDate.toISOString().split('T')[0],
        description: `Time tracking invoice for ${project.name} (${selectedEntries.length} entries)`,
        isAutoGenerated: true,
        timeEntriesIds: timeEntryIds.map(id => id.toString())
      };

      const invoice = await storage.createInvoice(invoiceData);
      return invoice;
    } catch (error) {
      throw new Error(`Failed to generate invoice: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async getUnbilledTimeEntries(projectId?: number): Promise<UnbilledTimeEntry[]> {
    try {
      const timeEntries = await timeTrackingService.getTimeEntries(projectId);
      const invoices = await storage.getInvoices();
      
      // Get all time entry IDs that are already billed
      const billedEntryIds = new Set<number>();
      invoices.forEach(invoice => {
        if (invoice.timeEntriesIds) {
          invoice.timeEntriesIds.forEach(id => billedEntryIds.add(parseInt(id)));
        }
      });

      // Filter unbilled entries
      const unbilledEntries = timeEntries.filter(entry => 
        !billedEntryIds.has(entry.id) && !entry.isActive
      );

      // Get project and client details
      const projects = await storage.getProjects();
      const projectMap = new Map(projects.map(p => [p.id, p]));

      return unbilledEntries.map(entry => {
        const project = projectMap.get(entry.projectId);
        return {
          id: entry.id,
          projectId: entry.projectId,
          projectName: project?.name || 'Unknown Project',
          clientName: project?.client?.name || 'Unknown Client',
          description: entry.description,
          duration: entry.duration,
          hourlyRate: entry.hourlyRate,
          totalCost: entry.totalCost,
          date: entry.createdAt
        };
      });
    } catch (error) {
      throw new Error(`Failed to get unbilled entries: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async getBillingStats(): Promise<BillingStats> {
    try {
      const unbilledEntries = await this.getUnbilledTimeEntries();
      const invoices = await storage.getInvoices();
      
      const totalUnbilledHours = unbilledEntries.reduce((sum, entry) => sum + entry.duration, 0) / 60;
      const totalUnbilledAmount = unbilledEntries.reduce((sum, entry) => sum + entry.totalCost, 0);
      
      // Calculate this month's billing
      const currentMonth = new Date().getMonth();
      const currentYear = new Date().getFullYear();
      const thisMonthInvoices = invoices.filter(invoice => {
        const invoiceDate = new Date(invoice.createdAt);
        return invoiceDate.getMonth() === currentMonth && invoiceDate.getFullYear() === currentYear;
      });
      const totalBilledThisMonth = thisMonthInvoices.reduce((sum, invoice) => sum + parseFloat(invoice.amount), 0);

      // Calculate average hourly rate
      const allTimeEntries = await timeTrackingService.getTimeEntries();
      const averageHourlyRate = allTimeEntries.length > 0 
        ? allTimeEntries.reduce((sum, entry) => sum + entry.hourlyRate, 0) / allTimeEntries.length 
        : 0;

      return {
        totalUnbilledHours,
        totalUnbilledAmount,
        totalBilledThisMonth,
        averageHourlyRate,
        nextBillingDates: [] // Simplified for now
      };
    } catch (error) {
      throw new Error(`Failed to get billing stats: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async runAutomaticBilling(): Promise<{ invoicesGenerated: number; totalAmount: number }> {
    try {
      const activeRules = Array.from(this.billingRules.values()).filter(rule => rule.isActive);
      let invoicesGenerated = 0;
      let totalAmount = 0;

      for (const rule of activeRules) {
        if (this.shouldRunBilling(rule)) {
          const unbilledEntries = await this.getUnbilledTimeEntries(rule.projectId);
          
          if (unbilledEntries.length > 0) {
            const projectEntries = rule.projectId 
              ? unbilledEntries.filter(entry => entry.projectId === rule.projectId)
              : unbilledEntries;

            if (projectEntries.length > 0) {
              const groupedByProject = this.groupEntriesByProject(projectEntries);
              
              for (const [projectId, entries] of Array.from(groupedByProject.entries())) {
                const invoice = await this.generateInvoiceFromTimeEntries(
                  projectId, 
                  entries.map((e: UnbilledTimeEntry) => e.id)
                );
                invoicesGenerated++;
                totalAmount += parseFloat(invoice.amount);
              }
            }
          }
        }
      }

      return { invoicesGenerated, totalAmount };
    } catch (error) {
      throw new Error(`Failed to run automatic billing: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private shouldRunBilling(rule: BillingRule): boolean {
    const now = new Date();
    
    switch (rule.frequency) {
      case 'weekly':
        return rule.dayOfWeek !== undefined && now.getDay() === rule.dayOfWeek;
      case 'monthly':
        return rule.dayOfMonth !== undefined && now.getDate() === rule.dayOfMonth;
      case 'on_completion':
        return false; // This would need project completion logic
      default:
        return false;
    }
  }

  private groupEntriesByProject(entries: UnbilledTimeEntry[]): Map<number, UnbilledTimeEntry[]> {
    const grouped = new Map<number, UnbilledTimeEntry[]>();
    
    for (const entry of entries) {
      if (!grouped.has(entry.projectId)) {
        grouped.set(entry.projectId, []);
      }
      grouped.get(entry.projectId)!.push(entry);
    }
    
    return grouped;
  }

  private getTaxRateForProject(projectId: number): number {
    const rule = Array.from(this.billingRules.values()).find(r => r.projectId === projectId);
    return rule?.taxRate || 10.0; // Default 10% tax
  }
}

export const billingService = new BillingService();